<?xml version="1.0" encoding="UTF-8"?>
<article version="5.0" xmlns="http://docbook.org/ns/docbook"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:html="http://www.w3.org/1999/xhtml"
         xmlns:xl="http://www.w3.org/1999/xlink">
    <info>
        <title>Vaadin JPAContainer Manual</title>
        <author>
            <personname>
                <firstname>Petter</firstname>
                <surname>Holmstr√∂m</surname>
            </personname>
            <email>petter.holmstrom@itmill.com</email>
        </author>
        <copyright>
            <year>2009, 2010</year>
            <holder>Oy IT Mill Ltd.</holder>
        </copyright>
    </info>

    <section xml:id="introduction">
        <title>Introduction</title>
        <para>
            Vaadin JPAContainer is a <link xl:href="http://vaadin.com">Vaadin</link> data container that uses the Java Persistence API 1.0 (JPA) for retrieving and storing data.
            It supports the most common features required by JEE applications out of the box, such as lazy loading, advanced filtering, nested property names and caching.
            It will probably not solve all the container problems you as a JEE application developer might face, but it will hopefully make your life a little easier.
        </para>
        <para>
            The purpose of this manual is to briefly explain how JPAContainer works and how you can use it in your applications. The manual describes the architecture of JPAContainer and
			the idea behind the components that it consists of. Next, the manual covers the most important features of JPAContainer and also points out some potential issues
			that developers should be aware of when using JPAContainer. Finally, it gives a brief description of how JPAContainer can be customized by developers.
        </para>
<!--        <note>
            <title>Work in progress</title>
            <para>
                This manual is a work in progress. Many sections have been described very shallowly, more depth will be added later. If you think something is missing,
                please let me now ASAP!
            </para>
        </note>-->
        <section>
            <title>Architecture</title>
            <para>
                The architecture of JPAContainer consists of two main components: an <interfacename>EntityContainer</interfacename> and an <interfacename>EntityProvider</interfacename>:
            </para>

            <mediaobject>
                <imageobject role="html">
                    <imagedata align="center" fileref="provider.png"/>
                </imageobject>
                <imageobject role="fo">
                    <imagedata scale="60" smallscale="100%" align="center" fileref="provider.png"/>
                </imageobject>
            </mediaobject>

            <para>
                The <interfacename>EntityContainer</interfacename> is an extended version of the standard Vaadin container and can be used directly to power e.g. tables or combo boxes.
                The container gets its data from an <interfacename>EntityProvider</interfacename>, which in turn loads the data from some data source. It is possible to have several
                containers using the same provider, making it possible to e.g. add a second-level cache to the provider. It is even possible to deploy the containers and the provider
                to different JVMs:
            </para>

            <mediaobject>
                <imageobject role="html">
                    <imagedata align="center" fileref="distributed.png"/>
                </imageobject>
                <imageobject role="fo">
                    <imagedata scale="60" smallscale="100%" align="center" fileref="distributed.png"/>
                </imageobject>
            </mediaobject>

            <para>
                Most of the public API of JPAContainer is defined in interfaces. The following diagram displays the most important classes and interfaces, and their relations. The gray
                interfaces are part of the official Vaadin API.
            </para>

            <mediaobject>
                <imageobject role="html">
                    <imagedata align="center" fileref="interfaces.png"/>
                </imageobject>
                <imageobject role="fo">
                    <imagedata scale="60" smallscale="100%" align="center" fileref="interfaces.png"/>
                </imageobject>
            </mediaobject>

<!--            <para>
                The <classname>JPAContainer</classname> class is the default implementation of the <interfacename>EntityContainer</interfacename> interface.
            </para>-->
        </section>
    </section>

    <section xml:id="using">
        <title>Using JPAContainer in Applications</title>
        <para>
            In this section we are going to look at how to use JPAContainer in your own applications. It is very easy to get started, all you need is the following code:
        </para>

        <programlisting language="java"><![CDATA[
EntityContainer<MyEntity> container = new JPAContainer<MyEntity>(
    MyEntity.class);
container.setEntityProvider(myEntityProvider);
        ]]></programlisting>

        <para>
            The entity provider can be any of the built-in entity providers (see <xref linkend="providers"/>) or your own custom built entity provider (see <xref linkend="custom-entity-providers"/>).
            We will return to this later in this manual.
        </para>

        <para>
            One thing to keep in mind when working with JPAContainer is that it is centered around <emphasis>entities</emphasis>, i.e. POJOs annotated with JPA annotations.
            JPAContainer will analyze the class definition and the annotations to access properties, determine which properties are sortable, etc. JPAContainer will
            <emphasis>not</emphasis> work with objects of classes that lack JPA annotations.
        </para>
        <para>
            JPAContainer differs between persistent properties and transient properties. Persistent properties are determined from the JPA annotations. If an entity
            class uses field annotations, the names of the persistent properties are the names of the non-transient fields. This is important to remember, especially if
            the field names and their corresponding getter/setter methods do not have mathing names.
        </para>
        <para>
            If an entity class uses method annotations, the names of the persistent properties are the JavaBean names of the non-transient getter methods. This also
            applies to transient properties, which are all the transient JavaBean properties of the entity class. Transient properties may be read-only, whereas persistent
            properties are always writable.
        </para>

        <section>
            <title>Nested Properties</title>
            <para>
                JPAContainer supports nested properties. You define nested properties using the <methodname>EntityContainer.addNestedContainerProperty(..)</methodname> method. For example,
                let's say you have an entiy class that looks like this:
            </para>

            <programlisting language="java"><![CDATA[@Entity
public class Person implements Serializable {

    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Long id;
    @Version
    private Long version;
    private String firstName;
    private String lastName;
    @Temporal(TemporalType.DATE)
    private Date dateOfBirth;
    @Embedded
    private Address address;

    // Getter and setter methods omitted
}

@Embeddable
public class Address implements Serializable, Cloneable {

    private String street;
    private String postalCode;
    private String postOffice;

    // Getter and setter methods omitted
}
            ]]></programlisting>

            <para>
                Now, let's say you want to show a list of persons, together with their addresses, in a Vaadin table. You also want to be able to filter
                and sort by street, postal code and post office. All you need to do to make this possible is the following:
            </para>

            <programlisting language="java"><![CDATA[myContainer.addNestedContainerProperty("address.*");}]]></programlisting>

            <para>
                The wildcard asterisk will expand to all the properties of the <classname>Address</classname> class. After this method call, the container will contain the following new properties, in addition to the existing ones:
                <varname>address.street</varname>, <varname>address.postalCode</varname> and <varname>address.postOffice</varname>.
                These properties are no different from the other properties and can be used in the same way.
            </para>
            <para>
                It is also possible to add individual nested properties. In that case, simply replace the wildcard asterisk with the property name.
            </para>
            <para>
                Nested properties can be removed from the container using the <methodname>EntityContainer.removeContainerProperty(..)</methodname> method. Removing a property from the container
                does not affect the property value, but prevents the container from accessing its value.
            </para>
            <para>
                Nested properties can also be defined on the item level. Normally, the properties accessible from an item is all the available properties of the entity class
                and any nested properties defined in the owning container. If these are not sufficient enough, additional nested properties can be added to a specific item
                by using the <methodname>EntityItem.addNestedContainerProperty(..)</methodname> method. Nested properties added this way will not show up in the container.
            </para>
        </section>
        <section>
            <title>Filtering</title>
            <para>
                The filtering in JPAContainer (defined in the <interfacename>AdvancedFilterable</interfacename> interface) is more advanced than the standard
                Vaadin <interfacename>Container.Filterable</interfacename> filtering. Although standard Vaadin filtering is also supported, it is recommended to
                use the new filtering API in applications.
            </para>
            <para>
                The JPAContainer filtering API is very similar to JPA 2.0 criteria. Filters are specified by adding instances of the <interfacename>Filter</interfacename>-interface
                to the container using the <methodname>AdvancedFilterable.addFilter(..)</methodname> method. As filters are intended to be applied in the database, only
                persistent properties can be filtered. All filters generate standard JPA QL-language that can be used by entity providers when constructing queries to be passed to an <interfacename>EntityManager</interfacename>.
            </para>
            <para>
                There are several predefined filters available in the <classname>Filters</classname> class, found in the <package>com.vaadin.addon.jpacontainer.filter</package> package:
            </para>

            <programlisting language="java"><![CDATA[
container.addFilter(Filters.like("firstName", "Jo%", false));
container.addFilter(Filters.or(
    Filters.eq("lastName", "Smith", false),
    Filters.eq("lastName", "Cool", false)
));
            ]]></programlisting>

            <para>
                The above example would include all entites whose first names start with "Jo" and last names are either "Smith" or "Cool" (case ignored). Filters can be applied to other data types as well,
                such as integers and timestamps. It is also possible to create custom filters by implementing the <interfacename>Filter</interfacename> interface.
            </para>
            <para>
                Filters can be either applied immediately or explicitly, depending on the state of the <varname>AdvancedFilterabe.isApplyFiltersImmediately</varname> flag.
                When applied immediately, each call to <methodname>AdvancedFilterable.addFilter(..)</methodname> forces
                the container to refresh itself. If only one filter is to be added, this may be desirable. However, if several filters are to be added it may be better to wait
                until all the filters have been defined before applying them. In this case, <methodname>AdvancedFilterable.applyFilters()</methodname> has to be called to apply
                the filters.
            </para>
            <para>
                Please note, that all filtering is done in the database. Therefore special care should be taken to make sure filterable columns are indexed properly, especially
                if the number of records is large.
            </para>
        </section>
        <section>
            <title>Editing</title>
            <para>
                The JPAContainer supports editing, but it uses a slightly different API than the default Container API. In order to make a JPAContainer editable, the entity provider
                must implement the <interfacename>MutableEntityProvider</interfacename> interface. In addition, the JPAContainer must not be marked as read-only.
            </para>
            <para>
                There is only one way of adding new items to the container and that is by using <methodname>EntityContainer.addEntity(..)</methodname>. Note, that this method
                takes the entity instance and not the <interfacename>EntityItem</interfacename> as a parameter. The returned value is an identifier that can be used to get
                the newly added entity's <interfacename>EntityItem</interfacename> by passing it to <methodname>EntityContainer.getItem(..)</methodname>.
            </para>
            <para>
                Especially when using a Vaadin form for editing items, it might be necessary to wrap an entity object inside an <interfacename>EntityItem</interfacename> before
                the entity has been added to the container. This can be done by using the <methodname>EntityContainer.createEntityItem(..)</methodname> method. This method will
                create a new <interfacename>EntityItem</interfacename> that has access to all the fields defined in the container, but is not contained in the container yet.
                The following code example demonstrates its usage:
            </para>

            <programlisting language="java"><![CDATA[
EntityItem<Customer> myNewItem = customerContainer.createEntityItem(
    new Customer());
// Do something with the item, e.g. open a modal dialog
Object id = customerContainer.addEntity(myNewItem.getEntity());
item = customerContainer.getItem(id);
            ]]></programlisting>

            <para>
                Changes made to existing <interfacename>EntityItem</interfacename>s will automatically be propagated back to the container (see <xref linkend="buffered_mode"/>).
                Existing items can also be removed from the container using the standard <methodname>Container.removeItem(..)</methodname> method.
            </para>

        </section>
        <section>
            <title>Managed Entities</title>
            <para>
                JPAContainer can display managed entities, i.e. entities that are managed by a persistence context. This makes it possible to lazily load both references
                and collections. It also means that any changes made to the entities show up in the persistence context directly and are persisted to the data base
                when the entity manager is flushed.
            </para>
            <para>
                However, there are a few things to keep in mind when using managed entities. First of all, the persistence context must be configured to use extended scope instead
                of transaction scope. That way, the persistence context will be available for several transactions, which is a requirement if lazy loading is to be used in
                a web application.
            </para>
            <para>
                Second, the entitities returned from the entity provider must not be serialized and deserialized before they reach the container. In practice, this means
                that the entity provider and the container must run inside the same JVM.
            </para>
            <para>
                Finally, if editing entities is allowed, the entity provider should take care of flushing the entity manager when needed.
            </para>
            <para>
                Normally, it is easier to use detached entities in the JPAContainer, as this means that no changes will be automatically propagated back to the
                database unless explicitly requested. On the other hand, this also means that any references or collections that will be accessed by the container have
                to be eagerly fetched before the entity is detached.
            </para>
            <para>
                It is possible to ask the entity provider to explicitly detach the entities before they are returned to the JPAContainer. If the <methodname>EntityProvider.isEntitiesDetached()</methodname>
                method returns true, it is safe to assume that all entities returned by the provider are detached. If the method returns false, the entities may or may not
                be detached, depending on how the entity provider is implemented. For example, if an entity provider uses a transaction-scoped persistence context and
                each method runs inside its own transaction, the entities returned by the provider will be automatically detached.
            </para>
        </section>
        <section>
            <title>Transactions</title>
            <para>
                Transactions should be handled by the entity providers. Depending on how they are deployed, they can be either handled by the container (e.g.
                when the entity provider is deployed as an EJB) or manually. In either case, each method invocation on the entity provider should run
                in its own transaction.
            </para>
        </section>
        <section xml:id="buffered_mode">
            <title>Buffered mode</title>
            <para>
                Both <interfacename>EntityContainer</interfacename> and <interfacename>EntityItem</interfacename> extend the <interfacename>Buffered</interfacename> interface.
                This means that it is possible to buffer changes made to either individual items or to the container as a whole.
            </para>
            <para>
                The <interfacename>Buffered</interfacename> interface can be used to control both how data is read and how changes are written:
            </para>
            <variablelist>
                <varlistentry>
                    <term>Write-Through</term>
                    <listitem>
                        <para>
                            Controls whether changes should be written directly (on) or buffered (off).
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>Read-Through</term>
                    <listitem>
                        <para>
                            Controls whether changes should be read from the original data store (on) or from a buffer or cache (off).
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
            <section>
                <title>Container Buffering</title>
                <para>
                    The buffering capabilities of the container heavily depend on the capabilities of the underlying entity provider:
                </para>
                <variablelist>
                    <varlistentry>
                        <term>Write-Through</term>
                        <listitem>
                            <para>
                                When turned on, any changes are directly propagated to the entity provider. When turned off,
                                all changes are buffered in the container and sent to the entity provider only when <methodname>commit()</methodname> is called.
                                The changes can also be rolled back using <methodname>discard()</methodname>.
                            </para>
                            <para>
                                It is important to remember that buffered changes are <emphasis>not</emphasis> considered when the data is filtered or sorted, as these operations
                                are performed by the entity provider. Thus, newly added items always show up at the top of the container regardless of any sorting applied,
                                and modified items are filtered and sorted according to their "unmodified state". Only after the changes have been committed, filtering and sorting
                                will be applied to the new values.
                            </para>
                            <para>
                                By default, write-through is turned off if the entity provider supports it. To support buffering of changes, the entity provider must implement
                                the <interfacename>BatchableEntityProvider</interfacename> interface. This makes it possible to run all the updates as a batch inside a single transaction.
                                JPAContainer will keep a log of all the changes that have been made and will then pass these changes on to the entity provider in the same order as
                                they were made.
                            </para>
                            <para>
                                There are a few potential issues to keep in mind when using buffered mode and the entities use references to other entities within the same container.
                                The first thing to keep in mind is how cascading has been configured. Let us say that two entities have been added to the container and that the first
                                entity contains a reference to the second entity. If cascading is turned on, both entities will be persisted when the first entity is added to the entity
                                manager. If this has not been detected by the entity provider, it might proceed by adding the second entity to the entity manager as instructed by JPAContainer.
                                As a result, there might now be two copies of the second entity in the database.
                            </para>
                            <para>
                                A similar problem might occur if some entity references a newly created entity that is removed before it has been persisted. For example, let us say that
                                EntityA and EntityB have both been added to the container, but not committed yet. EntityA is then updated to reference EntityB. However, the user realizes
                                that he or she has made a mistake and removes EntityB from the container. EntityA will, however, still hold a reference to EntityB as JPAContainer does no
                                internal validation. When EntityA is persisted, the operation will cascade to EntityB, and suddenly EntityB is in the database although it was never committed.
                            </para>
                            <para>
                                If you think your application might run into problems like these, there are a few things you could do. First, make sure you perform enough validation every time
                                you remove or edit an entity so that any illegal references are cleaned up. Second, implement your own entity provider so that it is aware of the potential
                                problem situations and is able to deal with them.
                            </para>
                            <para>
                                This is also called Auto Commit in the EntityContainer API.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>Read-Through</term>
                        <listitem>
                            <para>
                                Read-through cannot be explicitly changed by the user. Read-through is off if the entity provider implements the <interfacename>CachingEntityProvider</interfacename>
                                and the cache is in use. Otherwise, read-through is always on, i.e. the data is read directly from the data store.
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </section>
            <section>
                <title>Item Buffering</title>
                <para>
                    The buffering capabilities of <interfacename>EntityItem</interfacename> are always the same regardless of the entity provider. One of the drawbacks when
                    using write-through in the container is that every time a property of an item is changed, the change is sent directly to the database and saved. This means
                    a lot of database round-trips and no way of discarding the changes. The solution to this problem is to either turn on buffering in the container or, if the
                    container does not support buffering, use buffering on the item level instead.
                </para>
                <variablelist>
                    <varlistentry>
                        <term>Write-Through</term>
                        <listitem>
                            <para>
                                When write-through is on, all changes made to a property are directly propagated back to the underlying entity object and the container.
                                When write-through is off, all changes are buffered inside the item and are only propagated to the underlying entity (and the container) when
                                <methodname>Buffered.commit()</methodname> is called. <methodname>Buffered.discard()</methodname> discards the changes and reloads the item
                                with the original property values.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>Read-Through</term>
                        <listitem>
                            <para>
                                When read-through is on, all data is read directly from the underlying entity object. This is possible even when write-through is off
                                and there are buffered changes. When read-through is off, data is read both from the underlying entity object (unchanged properties)
                                and the item buffer (changed properties).
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </section>
        </section>
        <section>
            <title>Multi-User Environments</title>
            <section>
                <para>
                    When used in read-only mode, JPAContainer works great in multi-user environments. However, as soon as data editing is introduced, there are a few
                    things to keep in mind, especially if the entity provider reads all data directly from the database without using a cache or a snapshot.
                </para>
                <para>
                    JPAContainer implements the <interfacename>EntityProviderChangeListener</interfacename> interface. If the entity provider implements the
                    <interfacename>EntityProviderChangeNotifier</interfacename>, JPAContainer will register itself as a listener. Everytime the entity provider
                    notifies JPAContainer that an entity has been added, updated or removed, JPAContainer will fire an item set change event.
                </para>
                <para>
                    When using a Vaadin table to show the contents of a container, there is a risk of the view and the model becoming out of synch with each other.
                    Everytime an item is selected in a table, the table will check with the container if such an item exists before the selection is changed. However,
                    in the user interface, the selection will change regardless of this check. This means that if a user selects an item that has been deleted, the user
                    interface will look like it has selected the deleted item, when the underlying model in fact contains the previous selection.
                </para>
                <para>
                    To work around this, there is a property in JPAContainer called <varname>containsIdFiresItemSetChangeIfNotFound</varname>. If this property
                    is true, the container will fire an item set change event every time <methodname>EntityContainer.containsId(..)</methodname> is called and the result
                    is false. Thus, if the user tries to select a deleted item, the table will automatically be updated and the deleted item(s) removed from the view.
                </para>
            </section>
        </section>
    </section>

    <section xml:id="providers">
        <title>Built-in EntityProviders</title>
        <para>
            There are two kinds of built-in entity providers. The <classname>LocalEntityProvider</classname> is the simplest one, which reads all the information
            directly from an <interfacename>EntityManager</interfacename>. In applications where the amount of data is small and database round-trips are fast, this
            provider is the safest choice.
        </para>
        <para>
            If the number of database round-trips should be reduced, <classname>CachingLocalEntityProvider</classname> should be used instead. It maintains a local
            cache of entities and query results and hence should perform faster than <classname>LocalEntityProvider</classname> if database round-trips are slow.
            However, it also requires more memory than <classname>LocalEntityProvider</classname>.
        </para>
        <section>
            <title>The LocalEntityProvider</title>
            <mediaobject>
                <imageobject role="html">
                    <imagedata align="center" fileref="localentityprovider.png"/>
                </imageobject>
                <imageobject role="fo">
                    <imagedata scale="60" smallscale="100%" align="center" fileref="localentityprovider.png"/>
                </imageobject>
            </mediaobject>
            <section>
                <title>LocalEntityProvider</title>
                <para>
                    A read-only, lazy loading entity provider that performs no caching and reads
                    its data directly from an <interfacename>EntityManager</interfacename>. In other words,
                    basically all calls to the entity provider result in a query being sent to the <interfacename>EntityManager</interfacename>.
                </para>
            </section>
            <section>
                <title>MutableLocalEntityProvider</title>
                <para>
                    Extends <classname>LocalEntityProvider</classname> with write support. All changes are directly sent to the entity manager. Transactions
                    can be handled either internally by the provider (by turning on the <varname>transactionsHandled</varname> flag) or by the container (e.g. by extending
                    the class and annotating the methods). The class also implements the <interfacename>EntityProviderChangeNotifier</interfacename> interface,
                    which means that it will notify any listening clients everytime an entity is added, updated or removed.
                </para>
            </section>
            <section>
                <title>BatchableLocalEntityProvider</title>
                <para>
                    The simplest possible implementation of the <interfacename>BatchableEntityProvider</interfacename> interface - an extension of <classname>MutableLocalEntityProvider</classname>
                    that simply passes itself to the <methodname>batchUpdate(..)</methodname> method. This will work properly if the entities do not contain any references to
                    other entities that are managed by the same container.
                </para>
            </section>
        </section>
        <section>
            <title>The CachingLocalEntityProvider</title>
            <para>
                All the caching entity providers are basically extensions of the local entity providers, with caching support
                added by a delegate class <classname>CachingSupport</classname>.
            </para>
            <mediaobject>
                <imageobject role="html">
                    <imagedata align="center" fileref="cachinglocalentityprovider.png"/>
                </imageobject>
                <imageobject role="fo">
                    <imagedata scale="60" smallscale="100%" align="center" fileref="cachinglocalentityprovider.png"/>
                </imageobject>
            </mediaobject>
            <section>
                <title>CachingLocalEntityProvider</title>
                <para>
                    A read-only, lazy loading entity provider that caches both entities and query results for different filter/sortBy combinations.
                    When the cache gets full, the oldest entries in the cache are removed. The maximum number of entities to cache and the maximum number
                    of entityIds to cache for each filter/sortBy combination can be manually set. The cache can also be manually flushed. When the
                    cache grows full, the oldest items are removed.
                </para>
            </section>
            <section>
                <title>CachingMutableLocalEntityProvider</title>
                <para>
                    A caching entity-provider with caching support. When an entity is added or updated, the cache is flushed in order to make sure
                    the added or updated entity shows up correctly when using filters and/or sorting. When an entity is removed, only the filter/sortBy-caches
                    that actually contain the item are flushed. Otherwise, this class works just like <classname>MutableLocalEntityProvider</classname>.
                </para>
            </section>
            <section>
                <title>CachingBatchableLocalEntityProvider</title>
                <para>
                    An extension of <classname>CachableMutableLocalEntityProvider</classname> that implements the <interfacename>BatchableEntityProvider</interfacename> and
                    passes itself to the <methodname>batchUpdate(..)</methodname> method. This will work properly if the entities do not contain any references to
                    other entities that are managed by the same container.
                </para>
            </section>
        </section>
        <section>
            <title>EntityProviders as Spring-managed Beans</title>
            <para>
                If you are creating an enterprise application using the Spring Framework, you might want to configure your entity providers as Spring managed beans.
                In the demo application, this is done by subclassing one of the built-in entity providers and adding the appropriate annotations to the subclass. For example:
            </para>
            <programlisting language="java"><![CDATA[
@Repository(value = "myEntityProvider")
public class MyEntityProviderBean
    extends MutableLocalEntityProvider<MyEntity> {

    @PersistenceContext
    private EntityManager em;

    protected LocalEntityProviderBean() {
        super(MyEntity.class);
    }

    @Override
    @Transactional(propagation = Propagation.REQUIRED)
    public MyEntity updateEntity(MyEntity entity) {
        return super.updateEntity(entity);
    }

    @Override
    @Transactional(propagation = Propagation.REQUIRED)
    public MyEntity addEntity(MyEntity entity) {
        return super.addEntity(entity);
    }

    @Override
    @Transactional(propagation = Propagation.REQUIRED)
    public void removeEntity(Object entityId) {
        super.removeEntity(entityId);
    }

    @Override
    @Transactional(propagation = Propagation.REQUIRED)
    public void updateEntityProperty(Object entityId,
            String propertyName, Object propertyValue)
            throws IllegalArgumentException {
        super.updateEntityProperty(entityId, propertyName,
            propertyValue);
    }

    @PostConstruct
    public void init() {
        setEntityManager(em);
        /*
         * The entity manager is transaction scoped, which means that
         * the entities will be automatically detached when the
         * transaction is closed. Therefore, we do not need to
         * explicitly detach them.
         */
        setEntitiesDetached(false);
    }
}
            ]]></programlisting>
        </section>
        <section>
            <title>EntityProviders as Stateless Session Beans</title>
            <para>
                You can also deploy your entity providers as stateless session beans (or, if you are using one of the caching providers, as stateful session beans).
                The idea is the same as for Spring managed beans:
            </para>
            <programlisting language="java"><![CDATA[
@Stateless
@TransactionManagement
public class MyEntityProviderBean extends
    MutableLocalEntityProvider<MyEntity> {

    @PersistenceContext
    private EntityManager em;

    protected LocalEntityProviderBean() {
        super(MyEntity.class);
    }

    @Override
    @TransactionAttribute(TransactionAttributeType.REQUIRED)
    public MyEntity updateEntity(MyEntity entity) {
        return super.updateEntity(entity);
    }

    @Override
    @TransactionAttribute(TransactionAttributeType.REQUIRED)
    public MyEntity addEntity(MyEntity entity) {
        return super.addEntity(entity);
    }

    @Override
    @TransactionAttribute(TransactionAttributeType.REQUIRED)
    public void removeEntity(Object entityId) {
        super.removeEntity(entityId);
    }

    @Override
    @TransactionAttribute(TransactionAttributeType.REQUIRED)
    public void updateEntityProperty(Object entityId,
            String propertyName, Object propertyValue)
            throws IllegalArgumentException {
        super.updateEntityProperty(entityId, propertyName,
            propertyValue);
    }

    @PostConstruct
    public void init() {
        setEntityManager(em);
        /*
         * The entity manager is transaction scoped, which means that
         * the entities will be automatically detached when the
         * transaction is closed. Therefore, we do not need to
         * explicitly detach them.
         */
        setEntitiesDetached(false);
    }
}
            ]]></programlisting>
        </section>
    </section>

<!--    <section xml:id="demo">
        <title>The Hitchhiker's Guide to The Demo Application</title>
        <para>
            TODO Write about the demo application
        </para>
    </section>-->

    <section xml:id="custom-entity-providers">
        <title>Developing Custom Entity Providers</title>
        <para>
            Although the built-in entity providers should be sufficient in every-day usage, there are use cases where you might have to develop a custom entity provider.
            These include customized queries, complex object structures that require special handling, or loading data from a different data store.
            Althogh JPAContainer requires JPA annotations in order to properly analyze the classes and extract the available properties, the entities themselves
            must not necessarily come from an EntityManager. In fact, by implementing your own entity provider, you can store them in any way you like.
        </para>
        <para>
            Before you start to implement your own entity provider, there are a few things you need to think of:
        </para>
        <itemizedlist>
            <listitem>
                <para>Do you need read-only or read-write support?</para>
            </listitem>
            <listitem>
                <para>Do you need caching?</para>
            </listitem>
            <listitem>
                <para>Do you need filtering and/or sorting?</para>
            </listitem>
            <listitem>
                <para>Do you need container-level buffering?</para>
            </listitem>
            <listitem>
                <para>How are you going to handle transactions?</para>
            </listitem>
            <listitem>
                <para>Will you load data directly from the data store or from a snapshot taken of the data store?</para>
            </listitem>
            <listitem>
                <para>How are you going to handle concurrent editing?</para>
            </listitem>
        </itemizedlist>
        <para>
            Once you know what you need to build, you have to pick the interfaces to implement:
        </para>
        <variablelist>
            <varlistentry>
                <term>EntityProvider</term>
                <listitem>
                    <para>
                        Basic interface for all entity providers, provides read-only support.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>MutableEntityProvider</term>
                <listitem>
                    <para>
                        If you entity provider requires read-write support.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>CachingEntityProvider</term>
                <listitem>
                    <para>
                        If your entity provider uses caching or loads its data from a snapshot of the data store.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>BatchableEntityProvider</term>
                <listitem>
                    <para>
                        If you require container level buffering.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>EntityProviderChangeNotifier</term>
                <listitem>
                    <para>
                        If you want the containers to refresh themselves when data is changed.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
        <para>
            Please check the JavaDocs for more information about how the interfaces
            should be implemented.
        </para>
    </section>
</article>
